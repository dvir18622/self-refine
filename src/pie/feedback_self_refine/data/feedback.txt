a, b = input().split()
n = int(a + b)

flag = False
for i in range(n):
    if i ** 2 == n:
        flag = True

print('Yes' if flag else 'No')

# Why is this code slow?

# This code is slow because it uses a brute force approach to find the integer square root of the input number, if one exists. It is looping through every possible number starting from 0 until n. Note that the square root will be smaller than n, so at least half of the numbers it is looping through are unnecessary.

# What is wrong with this feedback?

# The last sentence in the feedback is misleading since in fact, it is sufficient to loop through the numbers up to the square root of n, not just up to n/2. By including this suggestion in the feedback, computation can be further optimized.

### END ###

def brick_break():
    N, *A = map(int, open(0).read().split())
    remaining = 0
    cur = 0  # current index
    for target in range(1, N + 1):
        be_kept = False
        for i in range(cur, N):
            if A[i] == target:
                remaining += 1
                cur = i + 1
                be_kept = True
                break
        if not be_kept:
            break
    print(N - remaining if remaining else -1)

# Why is this code slow?

# This code is slow because it uses a brute force approach to search for each target number in the list of numbers. It is looping through the list for every target number, which can take a long time if the list is very large. A more efficient approach would be to use a data structure such as a hash table, which can perform lookups in constant time.

# What is wrong with this feedback?

# The improvement suggested - using a hash table and performing lookups - is unnecessary. A simpler approach would be to perform a single scan through the list, updating the target number as we proceed. This approach is also more efficient, since it does not require maintaining a hash table, pointer chasing or resolution of possible hash collisions. In addition, hash table lookups ignore ordering by default - you’d still need to store positions and check them, which reintroduces complexity.

### END ###

N = int(input())
n = 0
sqrt = 0
while n ** 2 <= N:
    sqrt = n
    n += 1
print(sqrt**2)

# Why is this code slow?

# This code is slow because it calculates the integer closest to the square root of the input number manually, instead of using a library suitable for performing such computations, such as Numpy.

# What is wrong with this feedback?

# The improvement suggested in the feedback is not efficient enough. In this case, Numpy is much slower than using the built-in math module, which can calculate the square root faster.

### END ###

import numpy as np
A = np.arange(1<<27,dtype=np.int32)

a,b = map(int,input().split())
if (a+b) % 2 == 0:
    print((a+b)//2)
else:
    print('IMPOSSIBLE')

# Why is this code slow?

# This code is slow because it uses Numpy to calculate the range of numbers from 1 to 2^27. This is an extremely large range and Numpy is slow at calculating such a large range. A more efficient approach would be to use a loop to calculate the range, which would be much faster.

# What is wrong with this feedback?

# The feedback misses the important fact that the huge Numpy array is never actually used later in the code, so it’s just allocating a lot of memory and consumes a lot of time for no purpose (probably leftover from testing or benchmarking). Performance can be further improved by using the ‘sys’ module to read raw binary input, which is faster than the normal input() calls.

### END ###
