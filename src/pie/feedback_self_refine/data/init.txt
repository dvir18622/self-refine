a, b = input().split()
n = int(a + b)

flag = False
for i in range(n):
    if i ** 2 == n:
        flag = True

print('Yes' if flag else 'No')

# Why is this code slow?

# This code is slow because it uses a brute force approach to find the integer square root of the input number, if one exists. It is looping through every possible number starting from 0 until n, when in fact it is sufficient to loop through the numbers up to the square root of n.

### END ###

def brick_break():
    N, *A = map(int, open(0).read().split())
    remaining = 0
    cur = 0  # current index
    for target in range(1, N + 1):
        be_kept = False
        for i in range(cur, N):
            if A[i] == target:
                remaining += 1
                cur = i + 1
                be_kept = True
                break
        if not be_kept:
            break
    print(N - remaining if remaining else -1)

# Why is this code slow?

# This code is slow because it uses a brute force approach to search for each target number in the list of numbers. It is looping through the list for every target number, which can take a long time if the list is very large. A simpler and more efficient approach would be to perform a single scan through the list, updating the target number as we proceed.

### END ###

N = int(input())
n = sqrt = 0
while n ** 2 <= N:
    sqrt = n
    n += 1
print(sqrt**2)

# Why is this code slow?

# This code is slow because it calculates the integer closest to the square root of the input number manually, instead of using a module suitable for performing such computations, such as the built-in math module.

### END ###

import numpy as np
A = np.arange(1<<27,dtype=np.int32)

a,b = map(int,input().split())
if (a+b) % 2 == 0:
    print((a+b)//2)
else:
    print('IMPOSSIBLE')

# Why is this code slow?

# This code is slow because it uses Numpy to calculate the range of numbers from 1 to 2^27. This is an extremely large range and Numpy is slow at calculating such a large range. This huge Numpy array is never actually used later in the code, so it’s just allocating a lot of memory and consumes a lot of time for no purpose (probably leftover from testing or benchmarking). Performance can be further improved by using the ‘sys’ module to read raw binary input, which is faster than the normal input() calls.

### END ###
